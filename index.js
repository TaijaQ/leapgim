// Generated by CoffeeScript 1.10.0
(function() {
  Leap = require('leapjs');;
  var Gesture, KeyboardAction, MainController, MouseAction, config, keyboard, loopController, mainController, processFrame, robot;

  robot = require("robotjs");

  config = require('./config.json');

  loopController = new Leap.Controller({
    inBrowser: false,
    enableGestures: true,
    frameEventName: 'deviceFrame',
    background: true,
    loopWhileDisconnected: false
  });

  MainController = (function() {
    function MainController() {
      this.gestureSequence = [];
      this.extendedFingers = [];
      this.timeout = false;
      this.lastGestureTime = 0;
      this.wait = 0;
    }

    MainController.prototype.setFrame = function(frame1) {
      this.frame = frame1;
    };

    MainController.prototype.run = function() {
      var currentGesture, currentGestureConfig, gestureController, j, len, mouseAction, ref, results, sequence;
      this.extendedFingers = this.getExtendedFingers();
      if (this.isInMouseMode()) {
        mouseAction = new MouseAction(this.frame.hands[0]);
        return mouseAction.run();
      } else {
        gestureController = new Gesture(this.frame, this.extendedFingers);
        currentGesture = gestureController.detect();
        if (currentGesture && currentGesture !== this.gestureSequence[this.gestureSequence.length - 1]) {
          this.lastGestureTime = new Date().getTime();
          this.gestureSequence.push(currentGesture);
          currentGestureConfig = config.gestures[currentGesture];
          this.wait = currentGestureConfig.wait;
          ref = config.gestureSequences;
          results = [];
          for (j = 0, len = ref.length; j < len; j++) {
            sequence = ref[j];
            if (sequence.gestures.arrayIsEqual(this.gestureSequence)) {
              console.log("found sequence -> " + sequence.action.keyCombo);
              if (sequence.action.type === "keyboard") {
                keyboard.runKeyCombo(sequence.action.keyCombo);
              }
              results.push(this.resetGestureSequence());
            } else {
              results.push(void 0);
            }
          }
          return results;
        }
      }
    };

    MainController.prototype.isInMouseMode = function() {
      return this.extendedFingers.length === 5;
    };

    MainController.prototype.getExtendedFingers = function() {
      var extendedFingers, finger, fingerMap, hand, j, len, ref;
      extendedFingers = [];
      if (this.frame.hands.length > 0) {
        hand = this.frame.hands[0];
        fingerMap = ["thumb", "index", "middle", "ring", "pinky"];
        ref = hand.fingers;
        for (j = 0, len = ref.length; j < len; j++) {
          finger = ref[j];
          if (finger.extended === true) {
            extendedFingers.push(fingerMap[finger.type]);
          }
        }
      }
      return extendedFingers;
    };

    MainController.prototype.resetGestureSequence = function() {
      return this.gestureSequence = [];
    };

    MainController.prototype.hasToWait = function() {
      var now;
      now = new Date();
      if ((now.getTime() - this.lastGestureTime) < this.wait) {
        return true;
      } else {
        return false;
      }
    };

    return MainController;

  })();

  Gesture = (function() {
    function Gesture(frame1, extendedFingers1) {
      this.frame = frame1;
      this.extendedFingers = extendedFingers1;
    }

    Gesture.prototype.detect = function() {
      var direction, dotProduct, gesture, j, len, pointableID, ref;
      if (this.frame.gestures.length > 0) {
        ref = this.frame.gestures;
        for (j = 0, len = ref.length; j < len; j++) {
          gesture = ref[j];
          switch (gesture.type) {
            case "circle":
              if (this.extendedFingers.arrayIsEqual(["thumb", "index"])) {
                pointableID = gesture.pointableIds[0];
                direction = this.frame.pointable(pointableID).direction;
                dotProduct = Leap.vec3.dot(direction, gesture.normal);
                if (dotProduct > 0) {
                  return 'oneFingerRotateClockwise';
                } else {
                  return 'oneFingerRotateContraClockwise';
                }
              }
          }
        }
      }
      return false;
    };

    return Gesture;

  })();

  MouseAction = (function() {
    function MouseAction(hand1) {
      this.hand = hand1;
    }

    MouseAction.prototype.run = function() {
      if (this.hand.pinchStrength > 0) {
        return console.log('hand.pinchStrength: ' + this.hand.pinchStrength);
      }
    };

    return MouseAction;

  })();

  KeyboardAction = (function() {
    function KeyboardAction() {}

    KeyboardAction.prototype.runKeyCombo = function(keyCombo) {
      var j, k, key, len, results;
      for (j = 0, len = keyCombo.length; j < len; j++) {
        key = keyCombo[j];
        robot.keyToggle(key, true);
      }
      results = [];
      for (k = keyCombo.length - 1; k >= 0; k += -1) {
        key = keyCombo[k];
        results.push(robot.keyToggle(key, false));
      }
      return results;
    };

    return KeyboardAction;

  })();

  processFrame = function(frame) {
    if (frame.valid && !mainController.hasToWait()) {
      mainController.setFrame(frame);
      return mainController.run();
    }
  };

  keyboard = new KeyboardAction();

  mainController = new MainController();

  loopController.connect();

  loopController.on('frame', processFrame);


  /*
      The Call of Cthulhu!
      checks if two arrays are equal
   */

  Array.prototype.arrayIsEqual = function(o) {
    var i, j, ref;
    if (this === o) {
      return true;
    }
    if (this.length !== o.length) {
      return false;
    }
    for (i = j = 0, ref = this.length; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
      if (this[i] !== o[i]) {
        return false;
      }
    }
    return true;
  };

}).call(this);
